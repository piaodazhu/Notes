简单工厂模式
	通过向构造函数指定参数，使其返回不同的对象。
外观模式
	隐藏系统复杂性
适配器模式
	父类与适配器交互，适配器与具体适配对象交互。
单例模式
	不管怎么Get，保证独一份。
工厂方法模式
	产出的产品由工厂类型决定。
抽象工厂模式
	工厂能生产一类功能集类似的产品，取决于工厂的实现。
构造器模式
	构造器作为参数传入构造函数，可以使构造出来的产品呈现不同的形态。
原型模式
	给各个类的原型取名字，用getset访问，get可以获得原型的副本。
中介者模式
	对象之间的操作通过一个共同可访问的中介来完成。中介需要做判断。
代理模式
	与代理打交道而不是实际执行者。
观察者模式
	一堆观察者注册在对象上，对象改变时通知他们，不管他们具体的后续操作。
命令模式
	把方法封装到对象中，以便整体传递。
迭代器模式
	已相同的方式遍历不同对象集。
组合模式
	已相同接口访问对象和对象集。
模版方法模式
	父类规定行为，把具体的实现延迟到子类实现。
策略模式
	允许业务类采取不同的策略。
状态模式
	用于分离状态和行为。
备忘录模式
	提供一个保存状态的接口，可以不暴露内部细节。
享元模式
	把多个对象都要访问的相同子对象抽离出来只保留一份，从单例映射表获取。
解释器模式
	设计一套语言及其解释。
装饰器模式
	通过装饰原对象，使其表现出不同的行为。
责任链模式
	链上对象指向下一个对象，链上对象可以判断当前处理是否在本对象职责范围，并提供处理函数，否则向后发送。
桥接模式
	把复杂抽象分开成两类对象的全连接组合。
访问者模式
	把一堆截然不同的对象作为被访问者，这一堆对象调用accept后会轮流接待访问者，访问者会根据对象做不同的操作。
